[Related Concepts]
In computer science, a programming language is said to have first-class functions if it treats functions as first-class citizens. Specifically, this means the language supports passing functions as arguments to other functions, returning them as the values from other functions, and assigning them to variables or storing them in data structures.[1]

By Value - Original not changed.  Arguments/parameters only available to that function, etc.

By Reference - Original changed.

[Declarations]
	Function Scope - Variable defined within function is available to entire function [34].
	Lexical Scope - Scope of an inner function contains the scope of a parent function [34].
	Local scope/varible - Variable declared within function, available only to that function.
	Global scope/variable - Variable declared outside of function, available from all scripts and functions. Properties of the Global Object.
	Block Scope - Variables in a block (anything within { } brackets) belong to the function the variable is in.  JavaScript prior to ECMAScript2015 DOES NOT HAVE block scope. Variables declared within a block can effect things outside of the block. This changed in 2015 when the Let Statement was introduced [See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variable_scope#Variable_scope].
	
	Ways of Declaring variables [25]:
	- var. This syntax can be used to declare both local and global variables.
	- By assigning values. For example, x = 42. This always declares a global variable. It generates a strict JavaScript warning. You shouldn't use this.
	- let. This can be used to declare a block scope local variable. When used inside a block, scope is limited to that block/statement [22].
	- constants - cannot change them, or have the same name as varables of functions in the same scope.
	
		var a = 0, b = 0;
		var a = 0;

		const MY_FAV = 7;
		const MY_OBJECT = {"key": "value"};

		Let Statement (kind of like var, but only locks scope to that function):
			let x = 1;
			if (x === 1) {
				let x = 2;
				console.log(x); // expected output: 2
			}
			console.log(x); // expected output: 1
	
		Let Block: 
			var x = 5;
			var y = 0;
			let (x = x+10, y = 12) {
				console.log(x+y); // 27
			}
			console.log(x + y); // 5
	
		Let Expression:
			var a = 5;
			let(a = 6) console.log(a); // 6
			console.log(a); // 5
	
	Hoisting:
		Variables and functions are hoisted to the top transparently, but ONLY a part of variable assignments are [https://www.w3schools.com/js/js_hoisting.asp].  
		This provides no advantge, since, as Mozilla writes, "However, variables that are hoisted return a value of undefined. So even if you declare and initialize after you use or refer to this variable, it still returns undefined".
		
		Example:
		var x = 5; // Initialize x
		elem = document.getElementById("demo"); // Find an element 
		elem.innerHTML = x + " " + y;           // Display x and y
		var y = 7; // Initialize y
		
		In "var y = 7;", only the "var y" half is actually hoisted to the top.  The "= 7;" part actually remains (Only variable declarations are hoisted to the top).  Why care?  Because if you declare variables later (with the keyword var), part of them may actually be hoisted to the top and return undefined.  To avoid this, declare variables at the beginning of the script and at the beginning of functions.  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variable_scope#Variable_hoisting.
	
	Notes on Declarations:
	- Access global variables using window.variable syntax).  
	- In web pages, but not NodeJS, the global object is "window". In node, the global object's called "global".
	- ONLY function declarations are hoisted -- hence immediately invoked function expressions, which wouldn't work right if they were hoisted to the top [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function].
	- Variables and constants declared with let or const are not hoisted! [https://www.w3schools.com/js/js_hoisting.asp].
	- Assigning value to variable that hasn't been declared makes it automatically become a global variable, unless in Strict Mode (since variables are not automatically created) [https://www.w3schools.com/js/js_scope.asp].  Use var to lock undeclared variables to that function's scope.
	- Do NOT create global variables unless you intend to. Your global variables (or functions) can overwrite window variables (or functions) [https://www.w3schools.com/js/js_scope.asp]. Any function, including the window object, can overwrite your global variables and functions.
	- May encounter errors in switch statements because there is only one underlying block.
	- Variables outside the scope of a top-level function are global [https://www.w3schools.com/js/js_scope.asp].
	
[Functions]
	Three basic ways to define: expression, declaration, constructor.

	Anonymous Function: function(a, b){return a+b;}

	Anonymous Function Assigned to Variable (Function Literal): var abc = function(a, b){return a+b;} [7]

	Immediately Invoked Function Expressions (IIFE):
		Example: (function() { alert('Hello World'); })();
		- Function is wrapped in parenthesis (to make it an expression), so that it's executed without invoking/calling it.
		- Purpose of IIFE is so variables cannot be accessed from outside of it (assigning the function to a variable will just display the functions result (not the function itself).
		- Also called: Self/immediately Invoking/Executing (Anonymous) Function Expression.

	Function Constructor: 
		- Example: new Function ([arg1[, arg2[, ...argN]],] functionBody)
		- Function Constructor/new keyword is least efficient method of using/creating functions. [5]

	Named Function Expression [30]: 
		Example: 
		var math = { 'factorial': function factorial(n) {
		}};
		
	Function Declaration:
		- Example: function abc() { var x = 1 }
		- Require a name.
		- Are hoisted.
		- More desireable because they're declared at compile time and can be used anytime in the scope due to hoisting (function expressions are not). [8]
	
	Function Expression:
		- Example: var abc = function() { var x = 1 }
		- Can be used as IIFE.
		- Can be anonymous.
		- Can be named, but optional.
		- NOT hoisted.
		
	Get Syntax: Binds an object property to a function that will be called when that property is looked up. [13] [16]
		- As property of object. [13]
		- Using Object.defineProperty(), to append a getter to an existing object later at any time, . [13]
		- __defineGetter__() - (DEPRECATED) [15]

	Set Syntax: binds an object property to a function to be called when there is an attempt to set that property. [14]	
	
		Native Function Properties:
		- .arguments [19], .caller, .length, .name, .displayName, .prototype
	Native Function Methods:
		- .apply [12], .bind, .call [11], .toSource, .toString, .isGenerator

	Arrow Functions [17]: 
		- Are shorter, and always anonymous.
		- Best suited for non-method functions and they can not be used as constructors (new keyword).
		- "this" is lexical (strict mode rules with regard to this are ignored).
		- Two Types of Syntax:
			- var func = x => x * x;                  // concise syntax, implied "return"
			- var func = (x, y) => { return x + y; }; // with block body, explicit "return" needed
	
	Handler Functions and Closures:
		- https://www.sitepoint.com/function-expressions-vs-declarations/
	
	Generator Functions (Functions with an asterix *): [21]
		- Generators are functions which can be exited and later re-entered. Their context (variable bindings) will be saved across re-entrances. Calling a generator function does not execute its body immediately; an iterator object for the function is returned instead. When the iterator's next() method is called, the generator function's body is executed until the first yield expression, which specifies the value to be returned from the iterator or, with yield*, delegates to another generator function. The next() method returns an object with a value property containing the yielded value and a done property which indicates whether the generator has yielded its last value as a boolean. Calling the next() method with an argument will resume the generator function execution, replacing the yield statement where execution was paused with the argument from next().
		- The yield() keyword pauses and resumes generator functions.
		- The yield* expression delegates to another generator or iterable object.
	
	Function Arguments/Parameters:
		- A JavaScript function does not perform any checking on parameter values (arguments), number of parameters, or type of parameters. [27]
		- If a function is called with missing arguments (less than declared), the missing values are set to: undefined. [27]
		- If a function is provided arguments it doesn't need (those not declared), use the arguments object to access them.  Why would you want to?  No idea. See: https://www.w3schools.com/js/tryit.asp?filename=tryjs_function_arguments [27].
		- JavaScript arguments are passed by value.  Changes to arguments are not visible (reflected) outside the function. [27]
		- Objects will behave like they are passed *by reference* (since they are values, even though I don't understand this, then). If a function changes an object property, it changes the original value. Changes to object properties are visible/reflected outside the function. [27]
		
	Rest Parameters (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters):
		- Are the three dots found before function parameters.
		- Allow indefinite number of arguments to a function. [18]
		
	Function Notes:
		- In JavaScript every function is actually a Function object. [5]
		- Functions have properties and methods, just like objects.
		- .arguments is deprecated, and doesn't work in Strict Mode [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments].  Use arguments variable instead of the .arguments property [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments].
		- Functions created with the New keyword do not form a closure. [6]
		- Global function methods can be created/added using Function.prototype. (Example: Function.prototype.construct = function(args){};) [12]
		- Functions are the only thing in JavaScript that create a new scope. [26]
		- A function defined as the property of an object is called a method. [28]
		- A function designed to create new objects is called a constructor. [28]
		
[Modules & Code Patterns]
	Folding Pattern: https://intrepidis.blogspot.co.uk/2013/04/javascript-folding-pattern.html
	Module Pattern (very common): http://metaduck.com/08-module-pattern-inheritance.html

	Modules are just objects written and meant to be reusable [https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc].

	"Though JavaScript provides no actual module construct yet, objects can be used to create publicly accessible subnamespaces, and functions can be used to create an isolated, private namespace inside of a module." [26]

[Classes]
https://stackoverflow.com/questions/1595611/how-to-properly-create-a-custom-object-in-javascript

[Global Properties]
Infinity
	- Infinity is a numeric value that represents positive infinity.
	- -Infinity is a numeric value that represents negative infinity.
	- Infinity is displayed when a number exceeds the upper limit of the floating point numbers, which is 1.797693134862315E+308.
	- -Infinity is displayed when a number exceeds the lower limit of the floating point numbers, which is -1.797693134862316E+308
		
[Global Functions]
	Eval() [23]
	- If the argument is an expression, eval() evaluates the expression. If the argument is one or more JavaScript statements, eval() executes the statements.	
		
	Number() [24]
	- The Number() function converts the object argument to a number that represents the object's value.
	- If the value cannot be converted to a legal number, NaN is returned.
	- If the parameter is a Date object, the Number() function returns the number of milliseconds since midnight January 1, 1970 UTC.
	
[Gotchas and Technicalities]
	- JavaScript only hoists declarations, not initializations or expressions.
	- https://stackoverflow.com/questions/17546953/cant-access-object-property-even-though-it-exists-returns-undefined
	- http://www.w3schools.com/js/js_mistakes.asp
	- https://stackoverflow.com/questions/7064673/is-return-from-constructor-necessary-when-creating-object-with-new
	- Commas are NOT operators, but can be used as part of a declaration statement to declare multiple variables per line [32]:
		Example: var a = 1, b = 2;
		But NOT: var a = 1, var b = 2; 
	- Semicolons ARE optional in javascript.  Only need to worry about including semicolors is if there is an *parenthesis before other characters, first on a line. [33]
	- Parenthesis CANNOT contain statements, so anything between them is treated as an expression.  This is what creates immediately-invoked-function-expressions [30].
	
[Things you May See, and What They Are]	
	- define(['param1', 'param2'], function() {}); https://stackoverflow.com/questions/16950560/what-is-define-function-in-javascript


[JQuery Dissection]
- https://stackoverflow.com/questions/4754560/help-understanding-jquerys-jquery-fn-init-why-is-init-in-fn
	
[Things to be Aware Of]
- Unobtrusive_JavaScript

[Questions]
"The scope rules for constants are the same as those for let block-scope variables. If the const keyword is omitted, the identifier is assumed to represent a variable."
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types (It should say "if the keyword is omitted").

"Invoking the Function constructor as a function (without using the new operator) has the same effect as invoking it as a constructor." [5]

Why no return statement when using new keyword?  https://stackoverflow.com/questions/5958417/javascript-function-and-object

[References]
1. https://en.wikipedia.org/wiki/First-class_function
2. https://en.wikipedia.org/wiki/JavaScript
3. https://en.wikipedia.org/wiki/Anonymous_function
4. https://en.wikipedia.org/wiki/Prototype-based_programming
5. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function
6. http://www.bennadel.com/blog/1909-javascript-function-constructor-does-not-create-a-closure.htm
7. https://stackoverflow.com/questions/12314905/exact-meaning-of-function-literal-in-javascript
8. https://stackoverflow.com/questions/336859/javascript-function-declaration-syntax-var-fn-function-vs-function-fn
9. https://en.wikipedia.org/wiki/Literal_(computer_programming)
10. https://en.wikipedia.org/wiki/Unobtrusive_JavaScript
11. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call
12. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply
13. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get
14. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set
15. https://stackoverflow.com/questions/812961/javascript-getters-and-setters-for-dummies
16. http://javascriptplayground.com/blog/2013/12/es5-getters-setters/
17. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
18. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters
19. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
20. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters
21. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*
22. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
23. http://www.w3schools.com/jsref/jsref_eval.asp
24. http://www.w3schools.com/jsref/jsref_number.asp
25. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types
26. http://eloquentjavascript.net/10_modules.html
27. http://www.w3schools.com/js/js_function_parameters.asp
28. http://www.w3schools.com/js/js_function_definition.asp
29. http://www.2ality.com/2012/09/expressions-vs-statements.html
30. https://en.wikipedia.org/wiki/Immediately-invoked_function_expression
31. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function
32.	https://stackoverflow.com/questions/15485735/use-of-commas-versus-semicolons-in-javascript
33. https://mislav.net/2010/05/semicolons/
34. https://pierrespring.com/2010/05/11/function-scope-and-lexical-scoping/
35. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#Block_statement